
###Chap 1. Introduction to Algorithm Design 算法设计概述###

导引：算法的概念

算法是完成特定任务的过程，是任何合理计算机程序背后的内涵。算法所解决的问题必须是通用的、良定义的，其描述如：

> 问题：排序
> 
> 输入：n 个值的序列
> 
> 输出：输入序列中值的重排序，满足 xxx 条件

算法将域内所有可能的输入转化为相应的输出，解决同一个问题，可能有多种算法。算法有三个目标：正确，高效，易实现。但这三个往往难以同时满足。生产中输出凑合满足要求并且不是性能瓶颈的程序就可以了，而只有当出现严重的性能/法律问题时才会去找其 最好的 解决方案。本章主要关注算法正确性的问题。

1.1 栗子：机器人工作路径优化

首先。将实际生产中电路板组装机器人操作的最短路径问题抽象化为算法的表示：

> 问题：给我那 80 分的离散留个纪念
>
> 输入：平面上 n 个点的集合 S
>
> 输出：遍历 S 中所有点的最短路径

* Attempt 1: Nearest-neighbor heruistic

从特定点出发，寻找与当前点最近的未处理点。简单，易实现，快的一比，唯一的缺点：路线出现了根本错误，这是严重的政治问题。

通过特别构造的一个简单栗子即可打发掉这个 heruisic。

* Attempt 2: Closest-pair heuristic

重复连接最近的点对，构成一个环。也可以通过特别构造的简单栗子打发掉。

* WTF: 老子不干了，遍历所有排列，找最小值

你先边上等着吧。正解：Traveling Salesman Problem (TSP) 位于 16.4.

1.2 栗子：工作调度问题

各个工作有不同的特定时段，时段之间有重叠，单线程，要做数量上尽量多的工作。抽象化之后开始尝试：

* Attempt 1: Work whenever available 我们先谈一上午人生，当然这段时间你能刷若干道 LeetCode。

* Attempt 2: Taking the shortest 我们先谈一上午人生，再谈笑风生一下午，当然如果你非要像衡中的人一样跑一圈来把午饭解决掉的话那就滚蛋。

* Attempt 3: 老子再 Brute-force 好了吧。

    这次是 2^n 的，好了点。正解：
    
    ***取最先完成的。***
    
算法一定要保证正确性

算法 algorithm 与 启发 heuristic，前者始终输出正确结果，后者能有不错的效果但是不提供保障。

1.3 算法正确性推理

对于算法正确性做正确的形式化证明很难，如果证明过程有错误会有更大的思想问题。

* 证明正确性的前提：

    * 算法要解决的问题有清晰准确的描述。包括可能的输入集合，对输出的要求等。不要把问题做的太宽泛，目标要保持单一，否则问题往往没有好的算法甚至根本无解。对于描述中有歧义的要明确。在问题这方面，推荐遍历本书第二部分提供的 75 种问题目录，认真研究其定义，输入和输出，你的许多问题已经有解决方案了。
    
        一个很重要的技巧：不断缩小输入的范围，直到存在正确有效的算法。
        
    * 一套前提条件。
    
    * 算法本身的表述。准确描述出算法所执行的步骤。有三种方式：自然语言，伪代码，实际代码。实际上是表达能力与准确度的 tradeoff。使用你最喜欢的，我推荐用自然语言表达思想（思想是算法的核心），代码表达细节。清晰的表达是最终目的，不要为了装逼就到处扔伪代码。
    
    * 一系列推理的过程。

* 如何证伪：最简单的，提供反例，反例应该足够简单，没有额外的细节。

    提出反例的技巧：没基础的人算法，很小的数据也有可能出错。想的全面一点。在算法中寻找可能的弱点。尝试极端情况。


* 归纳与递归，数学归纳法很常用，而递归实际上就是数学归纳法。两个要素：一般情况和边界/ basis 情况。

* 累加，在算法分析中很常见，也是数学归纳法常用的地方。

    对于 arithmetic progressions，一次函数的累加是二次，二次累加是三次，etc.
    
    对于 geometric series，索引影响指数，其值取决于基数，基数小于零时值收敛于常数。该结论很重要：线性增加的项数之和可能是常数。
    
1.4 对问题建模

建模是把应用组织为简洁易懂的问题的艺术，为了充分利用算法的力量，问题需要抽象地表示出来，建模好可以省却设计甚至实现算法的工作（发现已经有轮子了），将应用程序简化为少数已有成熟解决方案的问题和结构。成功的建模的作用会在本书真实的故事中体现出来。而针对同一问题，也有多种不同的建模方式。建模仅仅是第一步，不同应用中的细节可能会有所影响，但是忽略一些细节可以解放思想。

* 组合性对象

    * 排列，例如序列、顺序、路径等。
    
    * 子集，顺序不重要，例如簇、集合、组、包、选择等。
    
    * 树，强调项目之间的层级关系，例如骨架、支配关系、祖先/子孙关系、分类等。
    
    * 图，对象对之间的关系，例如网络、电路、关系等。
    
    * 点，几何空间中的位置，例如地点、位置、数据记录等。
    
    * 多边形，几何空间中的区域，例如形状、区域、边界等。
    
    * 串，字符或模式的序列，例如文本、字符、模式、标签等。
    
每一种对象都有相应的算法问题，会在第二部分中详细展开。

* 递归性对象。递归思想：把大的东西看做由许多同样的小东西构成的。算法中递归结构很普遍，而以上的每一种结构都可以用递归表示。

    对于排列、子集、图和串，删掉其中的一个元素，便获得了更小的一个结构。对于点和多边形，可以通过线/弦将其分割。最小的多边形是三角形。
    
    和数学归纳法一样，递归定义对象也需要构成规则和基础情况。而最小的部分可以是 0 也可以是 1，更多是便利上的考虑。

1.5 关于 真实的故事

为了说明算法设计的巨大力量，加入一些真实的故事，包含个别我自己的，个别并不成功的，但都是客观真实第三方的。并且每个通常包含至少一个第二部分中涉及的问题。

1.6 真实的故事：超能力的建模栗子

寻找覆盖全部组合的最小集合是 NP 完全问题 set cover （引用：18.1）的一例，是难以计算的。

* 从候选集合 S 中生成所有 k 个元素的子集。解决方案（引用：14.5）。

* 需要确定某一时刻已经有多少组合得到了覆盖，这里使用 bit vector，常数时间访问。

* 需要一个搜索机制来确定下一个要买的彩票（数字集合）。对于小规模数据，暴力遍历，对于大规模数据，使用随机搜索过程如模拟退火（引用：7.5.3），确保选择的结果覆盖尽量多未覆盖的组合，重复多次并选择最好的结果，趋近最优。

而在最后发现我们的东西并没有和需求切合，做了很多额外的计算，提供了额外的不可分的结果。因为建模出现了错误，并不需要覆盖全部可能的中奖组合（话说这不就是需求工程问题么）。因此在试图解决问题之前，确保建模正确。