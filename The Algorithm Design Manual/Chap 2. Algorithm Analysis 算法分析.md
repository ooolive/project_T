###Chap 2. Algorithm Analysis 算法分析###

导引：算法的那一套理论

算法是 _大和谐_ 的，因为算法的理解与研究不依赖于语言或机器（机器独立的算法设计），理论上的研究并不需要被实现出来。

本节主要介绍两个重要的工具：RAM 计算模型和最坏情况的渐进复杂性。本书中最需要数学基础的 keeping score 也在本部分中。

2.1 RAM 计算模型

我们的研究建立在一个空想计算机的基础上，叫做 Random Access Machine，RAM。其特点有：

* 每一个简单操作（时间不随输入规模变化的操作）消耗一个单位时间。通过对单位时间计数确定算法的运行时间

* 循环和子程序不属于简单操作，其运行时间取决于循环次数和子程序本身设计。

* 每一次内存访问同样消耗一个单位时间，内存不限量，无视 cache 和虚拟内存。

该机器无视了简单操作的运行速度区别，cache，虚拟内存，循环展开、超线程等，其假设在现实中是基本不成立的，但该模型对我们理解算法很有帮助。

2.2 大 O 表示法

在考虑算法对全部数据的性能时，有最坏情况复杂度、最好复杂度和平均复杂度等，代表数值函数，其中最坏复杂度一般最管用，为啥？因为你长得丑。

精确计算算法的复杂度函数很需要基础，因为很多地方不确定性太多（比如二分搜索怎么就这么正好呢），细节也太多。而我们的主要目的是进行算法之间的***比较***，因此便可忽略一些层次的细节，只考虑上下界限。我们也并不关心 2 个元素的排序速度，我们的征途是星辰大海。

大 O 表示法忽略了系数等细节，形式化定义自己功夫网，懒得写。

大 O 表示法极大的简化了比较算法的工作，使得没事比比算法的资本主义歪风邪气不断蔓延，是国家和民族的罪人。

对于相关的无法确定的问题，***看定义***。

2.3 增长率和支配关系

时间复杂度从 lgn 到 n! 的算法在输入规模不断增长情况下的时间增长图。在 n = 10 时都挺淡定，到最后 lgn 同学表现最好，奖励一朵小红花。

10000000n^2 的算法可以随便鄙视 n^3，实际上系数/常数项差这么大的情况比输入巨大的情况少的多。增长快的函数 (如 libdispatch) 会迅速取得支配地位，在算法分析基础中我们往往只使用几个函数：

常数，对数，线性，超线性，二次，三次，指数，阶乘。

2.4 大 O 表示法的计算

大多数的小学三年级知识依然成立，但是也有例外。

大 O 表达式相加，libdispatch 会起支配作用。与常数相乘无影响，表达式之间相乘则需要将其内的函数相乘。大 O 关系是传递性的。 

2.5 关于效率的推理实例

选择排序：不断选出未排序集中的最值并放在排序集最后。列出来是嵌套累加表达式，可以采用平均值或上下界的方式求出复杂度。

插入排序：可以直接将循环次数向上估为 n 次。

字符串匹配：文本字符串最基础的算法，任何一个 Web 浏览器和编辑器都有的功能。 θ(nm)

矩阵相乘：还是嵌套累加。

针对特定任务的算法设计会涉及到对多种可能性的考虑和选择，其熟练来自于实践。而算法分析则需要慢慢去做。

2.6 对数及其应用

Logarithm 和 algorithm 是同字母异序词。对数一般出现在问题被不断折半或加倍时。

二分查找：算法设计中最吊的东西之一。

树：二叉树的叶子数 n =  2^h，可推广到 n 叉树。二叉树是高速数据结构设计的基础。

位：log2n 位有 n 种位模式。

乘法：对数在计算器之前的时代很有用。

快速指数计算：分治，我记得 LeetCode 里面有这玩意。需要精确的值，受到精度限制。经常用在密码学里的素数测试中（引用：13.8）

累加：

刑事判决：诈骗罪根据金额的对数定刑期。

2.7 对数的性质

大多数相关算法里面都是以 2 为底的对数，一般是重复折半/加倍的后果，以 10 为底的对数在前计算器时代有很多使用。

换底公式：logab = logcb / logca

对数的底对其增长率影响不大。并且对其他函数的增长率有可啪的减小作用。